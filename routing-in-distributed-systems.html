<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF" data-link-color="#307FFF" data-content-max-width="1350" data-resizable-sidebar="true" data-sidebar-width="300"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-09-11T21:13:46.070453197"><title>Routing in Distributed Systems | Mind and Hand</title><script type="application/json" id="virtual-toc-data">[{"id":"question","level":0,"title":"question","anchor":"#question"},{"id":"answer","level":0,"title":"answer","anchor":"#answer"},{"id":"client-side-routing","level":1,"title":"客户端路由 client-side routing","anchor":"#client-side-routing"},{"id":"server-side-routing","level":1,"title":"服务端路由 server-side routing","anchor":"#server-side-routing"},{"id":"b9au19_13","level":1,"title":"对比例子","anchor":"#b9au19_13"},{"id":"redis-cluster","level":1,"title":"Redis Cluster","anchor":"#redis-cluster"},{"id":"redis-cluster-slot","level":1,"title":"Redis Cluster 节点如何管理 slot？","anchor":"#redis-cluster-slot"},{"id":"slot","level":2,"title":"一、slot 是怎么分配给节点的？","anchor":"#slot"},{"id":"slot_2","level":2,"title":"二、slot 元数据存储在哪？","anchor":"#slot_2"},{"id":"slot_3","level":2,"title":"三、节点之间如何同步 slot 信息？","anchor":"#slot_3"},{"id":"slot_4","level":2,"title":"四、slot 迁移是怎么进行的？(Re-sharding)","anchor":"#slot_4"},{"id":"slot_5","level":2,"title":"五、如何查看 slot 分布？","anchor":"#slot_5"},{"id":"b9au19_7","level":0,"title":"总结对比","anchor":"#b9au19_7"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Routing in Distributed Systems | Mind and Hand"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Mind and Hand Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/routing-in-distributed-systems.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Routing in Distributed Systems | Mind and Hand"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/routing-in-distributed-systems.html#webpage",
    "url": "writerside-documentation/routing-in-distributed-systems.html",
    "name": "Routing in Distributed Systems | Mind and Hand",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Mind and Hand Help"
}</script><!-- End Schema.org --></head><body data-id="routing-in-distributed-systems" data-main-title="Routing in Distributed Systems" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="develop.md|Develop///distributed.md|Distributed System"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Mind and Hand  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="routing-in-distributed-systems" id="routing-in-distributed-systems.md">Routing in Distributed Systems</h1><aside class="prompt" data-type="tip" data-title="" id="b9au19_4"><p id="b9au19_8">分布式系统中的路由</p></aside><section class="chapter"><h2 id="question" data-toc="question">question</h2><p id="b9au19_9">分布式系统中的路由有谁来负责？客户端还是服务端？</p></section><section class="chapter"><h2 id="answer" data-toc="answer">answer</h2><p id="b9au19_10">两种方式都存在，要看具体系统的设计选择</p><section class="chapter"><h3 id="client-side-routing" data-toc="client-side-routing">客户端路由 client-side routing</h3><p id="b9au19_16">客户端自己决定请求发到哪个节点，例如</p><ul class="list _bullet" id="b9au19_17"><li class="list__item" id="b9au19_24"><p id="b9au19_26">通过一致性哈希（Consistent Hashing）或某种分片规则定位到具体节点</p></li><li class="list__item" id="b9au19_25"><p id="b9au19_27">通常客户端会缓存一份集群拓扑信息或元数据</p></li></ul><p id="b9au19_18"><span class="control" id="b9au19_28">代表系统：</span></p><ul class="list _bullet" id="b9au19_19"><li class="list__item" id="b9au19_29"><p id="b9au19_32">Cassandra</p></li><li class="list__item" id="b9au19_30"><p id="b9au19_33">Riak</p></li><li class="list__item" id="b9au19_31"><p id="b9au19_34">Kafka Producer（可以自己决定发送到哪个 partition）</p></li></ul><p id="b9au19_20"><span class="control" id="b9au19_35">优点：</span></p><ul class="list _bullet" id="b9au19_21"><li class="list__item" id="b9au19_36"><p id="b9au19_38">请求路径短，直接到目标节点</p></li><li class="list__item" id="b9au19_37"><p id="b9au19_39">减少跳转、中间层压力</p></li></ul><p id="b9au19_22"><span class="control" id="b9au19_40">缺点：</span></p><ul class="list _bullet" id="b9au19_23"><li class="list__item" id="b9au19_41"><p id="b9au19_43">客户端实现复杂，要感知集群拓扑变化</p></li><li class="list__item" id="b9au19_42"><p id="b9au19_44">拓扑变化（比如扩容）可能导致客户端缓存失效，需要有刷新机制</p></li></ul></section><section class="chapter"><h3 id="server-side-routing" data-toc="server-side-routing">服务端路由 server-side routing</h3><p id="b9au19_45">客户端只连接某个入口节点（称为 router、coordinator、proxy 等），再由这个节点在集群内部路由转发。</p><p id="b9au19_46"><span class="control" id="b9au19_52">代表系统：</span></p><ul class="list _bullet" id="b9au19_47"><li class="list__item" id="b9au19_53"><p id="b9au19_57">MongoDB（mongos）</p></li><li class="list__item" id="b9au19_54"><p id="b9au19_58">TiDB（SQL 层接入）</p></li><li class="list__item" id="b9au19_55"><p id="b9au19_59">HBase（通过 RegionServer）</p></li><li class="list__item" id="b9au19_56"><p id="b9au19_60">Elasticsearch（coordinating node）</p></li></ul><p id="b9au19_48"><span class="control" id="b9au19_61">优点：</span></p><ul class="list _bullet" id="b9au19_49"><li class="list__item" id="b9au19_62"><p id="b9au19_64">客户端简单，不需要关心数据分布</p></li><li class="list__item" id="b9au19_63"><p id="b9au19_65">系统可以集中处理元数据、负载均衡</p></li></ul><p id="b9au19_50"><span class="control" id="b9au19_66">缺点：</span></p><ul class="list _bullet" id="b9au19_51"><li class="list__item" id="b9au19_67"><p id="b9au19_69">增加一跳，可能引入性能瓶颈</p></li><li class="list__item" id="b9au19_68"><p id="b9au19_70">入口节点成为潜在的热点或单点故障点（需高可用设计）</p></li></ul></section><section class="chapter"><h3 id="b9au19_13" data-toc="b9au19_13">对比例子</h3><p id="b9au19_71">Kafka（客户端路由）：</p><p id="b9au19_72">Kafka 的 producer 会从 broker 获取元数据，然后根据 topic 的 partition 和 key 做 hash，直接发送消息到对应的 broker。这样中间没有 proxy，性能高。</p><p id="b9au19_73">MongoDB（服务端路由）：</p><p id="b9au19_74">MongoDB 分片集群中，客户端连接 mongos，而不是直接连接 shard。mongos 是查询协调器，接收请求后根据 chunk 的分布信息，分发请求到对应 shard 上。</p></section><section class="chapter"><h3 id="redis-cluster" data-toc="redis-cluster">Redis Cluster</h3><p id="b9au19_75"><span class="control" id="b9au19_82">数据分片</span></p><ul class="list _bullet" id="b9au19_76"><li class="list__item" id="b9au19_83"><p id="b9au19_86">Redis Cluster 将整个 key 空间划分为 16384 个 slot（称为 <span class="control" id="b9au19_87">哈希槽</span>）。</p></li><li class="list__item" id="b9au19_84"><p id="b9au19_88">每个 key 通过 <code class="code" id="b9au19_89">CRC16(key) % 16384</code>得到其 slot 编号。</p></li><li class="list__item" id="b9au19_85"><p id="b9au19_90">每个节点负责其中的一部分 slot。</p></li></ul><p id="b9au19_77"><span class="control" id="b9au19_91">路由流程（客户端侧）：</span></p><ol class="list _decimal" id="b9au19_78" type="1"><li class="list__item" id="b9au19_92"><p id="b9au19_95"><span class="control" id="b9au19_96">客户端第一次连接时</span> ，会从任意一个 Redis 节点获取集群拓扑信息（即所有 slot 分布在哪些节点）。</p></li><li class="list__item" id="b9au19_93"><p id="b9au19_97"><span class="control" id="b9au19_98">计算 slot</span> ：发送命令时，客户端根据 key 计算它属于哪个 slot。</p></li><li class="list__item" id="b9au19_94"><p id="b9au19_99"><span class="control" id="b9au19_100">选择节点</span> ：根据 slot 到节点的映射，直接将命令发送到对应的节点。</p></li></ol><p id="b9au19_79"><span class="control" id="b9au19_101">如果客户端路由错了（比如映射信息过期），Redis 节点会返回：</span></p><ul class="list _bullet" id="b9au19_80"><li class="list__item" id="b9au19_102"><p id="b9au19_104"><code class="code" id="b9au19_105">-MOVED</code> ：告诉客户端该 slot 已经迁移到其他节点，客户端需更新 slot 映射表。</p></li><li class="list__item" id="b9au19_103"><p id="b9au19_106"><code class="code" id="b9au19_107">-ASK</code> ：表示 slot 正在迁移过程中，客户端暂时重定向到新节点（但不更新本地映射）。</p></li></ul><p id="b9au19_81">客户端需要支持这类重试和 slot 映射更新逻辑。</p></section><section class="chapter"><h3 id="redis-cluster-slot" data-toc="redis-cluster-slot">Redis Cluster 节点如何管理 slot？</h3><p id="b9au19_108">Redis Cluster 将 16384 个 slot 显式分配给集群中的节点。每个节点会维护一份 slot -&gt; 节点 的映射信息，并参与集群协议，确保这个映射在整个集群中是一致的。</p><section class="chapter"><h4 id="slot" data-toc="slot">一、slot 是怎么分配给节点的？</h4><p id="b9au19_115">在 Redis Cluster 启动或扩容时，管理员手动（或使用工具如 redis-cli --cluster create）将 slot 分配给节点。比如：</p><ul class="list _bullet" id="b9au19_116"><li class="list__item" id="b9au19_118"><p id="b9au19_121">节点 A：0 ~ 5460</p></li><li class="list__item" id="b9au19_119"><p id="b9au19_122">节点 B：5461 ~ 10922</p></li><li class="list__item" id="b9au19_120"><p id="b9au19_123">节点 C：10923 ~ 16383</p></li></ul><p id="b9au19_117">Redis 每个主节点（master）会维护自己负责的 slot 范围，并在 CLUSTER SLOTS、CLUSTER NODES 等命令中向外暴露这些信息。</p></section><section class="chapter"><h4 id="slot_2" data-toc="slot_2">二、slot 元数据存储在哪？</h4><p id="b9au19_124">每个 Redis 节点内部维护一张哈希表：</p><div class="code-block" data-lang="c">
struct clusterNode {
  int slots[16384]; // 每个节点记录自己负责哪些 slot
}
</div><p id="b9au19_126">此外，每个节点还记录所有其他节点的 IP、端口、角色（master/slave）、健康状态等集群元数据。</p></section><section class="chapter"><h4 id="slot_3" data-toc="slot_3">三、节点之间如何同步 slot 信息？</h4><p id="b9au19_127">Redis Cluster 节点通过 gossip 协议（定期交换心跳包和元数据）相互同步 cluster 状态，包括：</p><ul class="list _bullet" id="b9au19_128"><li class="list__item" id="b9au19_131"><p id="b9au19_134">每个节点负责的 slot 范围</p></li><li class="list__item" id="b9au19_132"><p id="b9au19_135">节点是否宕机</p></li><li class="list__item" id="b9au19_133"><p id="b9au19_136">主从关系是否发生切换</p></li></ul><p id="b9au19_129">slot 是否在迁移（migrating/importing）</p><p id="b9au19_130">这些信息帮助节点共同维持整个集群的一致视图。</p></section><section class="chapter"><h4 id="slot_4" data-toc="slot_4">四、slot 迁移是怎么进行的？(Re-sharding)</h4><p id="b9au19_137">当你想把部分 slot 从节点 A 移动到节点 B：</p><ol class="list _decimal" id="b9au19_138" type="1"><li class="list__item" id="b9au19_144"><p id="b9au19_145">设置状态标志：</p></li></ol><ul class="list _bullet" id="b9au19_139"><li class="list__item" id="b9au19_146"><p id="b9au19_148">A 设置 slot 为 <code class="code" id="b9au19_149">migrating</code></p></li><li class="list__item" id="b9au19_147"><p id="b9au19_150">B 设置该 slot 为 <code class="code" id="b9au19_151">importing</code></p></li></ul><ol class="list _decimal" id="b9au19_140" type="1" start="2"><li class="list__item" id="b9au19_152"><p id="b9au19_154">通过 <code class="code" id="b9au19_155">CLUSTER SETSLOT</code> 命令通知集群 slot 状态变化</p></li><li class="list__item" id="b9au19_153"><p id="b9au19_156">搬迁数据：</p></li></ol><ul class="list _bullet" id="b9au19_141"><li class="list__item" id="b9au19_157"><p id="b9au19_159">客户端或管理员使用 redis-cli --cluster reshard 工具</p></li><li class="list__item" id="b9au19_158"><p id="b9au19_160">将指定 slot 上的 key 从 A 拉到 B，通常用 MIGRATE 命令实现</p></li></ul><ol class="list _decimal" id="b9au19_142" type="1" start="4"><li class="list__item" id="b9au19_161"><p id="b9au19_162">完成后 slot 属于 B，更新集群状态</p></li></ol><p id="b9au19_143">客户端这时会收到 <code class="code" id="b9au19_163">ASK</code> 响应，提示临时重定向请求到目标节点。</p></section><section class="chapter"><h4 id="slot_5" data-toc="slot_5">五、如何查看 slot 分布？</h4><div class="code-block" data-lang="bash">
# 查看 slot -&gt; 节点映射
redis-cli -c -h 任意节点 cluster slots

# 查看节点视图（包含每个节点管理的slot）
redis-cli -c -h 任意节点 cluster nodes
</div></section></section></section><section class="chapter"><h2 id="b9au19_7" data-toc="b9au19_7">总结对比</h2><div class="table-wrapper"><table class="wide" id="b9au19_165"><thead><tr class="ijRowHead" id="b9au19_166"><th id="b9au19_169"><p>方式</p></th><th id="b9au19_170"><p>特点</p></th><th id="b9au19_171"><p>代表系统</p></th></tr></thead><tbody><tr id="b9au19_167"><td id="b9au19_172"><p>客户端路由</p></td><td id="b9au19_173"><p>高性能、需要客户端维护路由信息</p></td><td id="b9au19_174"><p>Cassandra、Kafka、Couchbase</p></td></tr><tr id="b9au19_168"><td id="b9au19_175"><p>服务端路由（代理）</p></td><td id="b9au19_176"><p>简化客户端逻辑、可集中控制负载，但增加中间跳转</p></td><td id="b9au19_177"><p>MongoDB、TiDB、HBase、ES</p></td></tr></tbody></table></div></section><div class="last-modified">11 September 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="distributed.html" class="navigation-links__prev">Distributed System</a><a href="develop-design.html" class="navigation-links__next">Program Design</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>