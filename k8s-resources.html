<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF" data-link-color="#307FFF" data-content-max-width="1350" data-resizable-sidebar="true" data-sidebar-width="300"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-09-11T09:27:01.36868731"><title>understand resources | Mind and Hand</title><script type="application/json" id="virtual-toc-data">[{"id":"introduction-to-kubernetes-limits-and-requests","level":0,"title":"Introduction to Kubernetes Limits and Requests","anchor":"#introduction-to-kubernetes-limits-and-requests"},{"id":"hands-on-example","level":0,"title":"Hands-on example","anchor":"#hands-on-example"},{"id":"kubernetes-requests","level":0,"title":"Kubernetes Requests","anchor":"#kubernetes-requests"},{"id":"kubernetes-limits","level":0,"title":"Kubernetes Limits","anchor":"#kubernetes-limits"},{"id":"cpu-particularities","level":0,"title":"CPU particularities","anchor":"#cpu-particularities"},{"id":"memory-particularities","level":0,"title":"Memory particularities","anchor":"#memory-particularities"},{"id":"best-practices","level":0,"title":"Best practices","anchor":"#best-practices"},{"id":"namespace-resourcequota","level":0,"title":"Namespace ResourceQuota","anchor":"#namespace-resourcequota"},{"id":"namespace-limitrange","level":0,"title":"Namespace LimitRange","anchor":"#namespace-limitrange"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/custom.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="understand resources | Mind and Hand"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Mind and Hand Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/k8s-resources.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="understand resources | Mind and Hand"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/k8s-resources.html#webpage",
    "url": "writerside-documentation/k8s-resources.html",
    "name": "understand resources | Mind and Hand",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Mind and Hand Help"
}</script><!-- End Schema.org --></head><body data-id="k8s-resources" data-main-title="understand resources" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="kubernetes.md|kubernetes"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Mind and Hand  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="k8s-resources" id="k8s-resources.md">understand resources</h1><p id="ne00x5_3">When working with containers in Kubernetes, it&rsquo;s important to know what are the resources involved and how they are needed. Some processes will require more CPU or memory than others. Some are critical and should never be starved.</p><p id="ne00x5_4">Knowing that, we should configure our containers and Pods properly in order to get the best of both.</p><section class="chapter"><h2 id="introduction-to-kubernetes-limits-and-requests" data-toc="introduction-to-kubernetes-limits-and-requests">Introduction to Kubernetes Limits and Requests</h2><p id="ne00x5_15">Limits and Requests are important settings when working with Kubernetes. This article will focus on the two most important ones: CPU and memory.</p><p id="ne00x5_16"><span class="control" id="ne00x5_19">Kubernetes defines Limits as the maximum amount of a resource</span> to be used by a container. This means that the container can never consume more than the memory amount or CPU amount indicated.</p><p id="ne00x5_17"><span class="control" id="ne00x5_20">Requests, on the other hand, are the minimum guaranteed amount of a resource</span> that is reserved for a container.</p><figure id="ne00x5_18"><img alt="Kubernetes limits and request 04 1 1170x585" src="images/Kubernetes-Limits-and-Request-04-1-1170x585.png" title="Kubernetes limits and request 04 1 1170x585" width="800" height="400"></figure></section><section class="chapter"><h2 id="hands-on-example" data-toc="hands-on-example">Hands-on example</h2><p id="ne00x5_21">Let&rsquo;s have a look at this deployment, where we are setting up limits and requests for two different containers on both CPU and memory.</p><div class="code-block" data-lang="yaml">
kind: Deployment
apiVersion: extensions/v1beta1
# ...
template:
  spec:
    containers:
      - name: redis
        image: redis:5.0.3-alpine
        resources:
          limits:
            memory: 600Mi
            cpu: 1
          requests:
            memory: 300Mi
            cpu: 500m
      - name: busybox
        image: busybox:1.28
        resources:
          limits:
            memory: 200Mi
            cpu: 300m
          requests:
            memory: 100Mi
            cpu: 100m
</div><p id="ne00x5_23">Let&rsquo;s say we are running a cluster with, for example, 4 cores and 16GB RAM nodes. We can extract a lot of information:</p><figure id="ne00x5_24"><img alt="Kubernetes limits and request 05 1170x828" src="images/Kubernetes-Limits-and-Request-05-1170x828.png" title="Kubernetes limits and request 05 1170x828" width="800" height="566"></figure><ol class="list _decimal" id="ne00x5_25" type="1"><li class="list__item" id="ne00x5_26"><p id="ne00x5_32"><span class="control" id="ne00x5_33">Pod effective request</span> is 400 MiB of memory and 600 millicores of CPU. You need a node with enough free allocatable space to schedule the pod.</p></li><li class="list__item" id="ne00x5_27"><p id="ne00x5_34"><span class="control" id="ne00x5_35">CPU shares</span> for the redis container will be 512, and 102 for the busybox container. Kubernetes always assign 1024 shares to every core, so redis: 1024 * 0.5 cores &cong; 512 and busybox: 1024 * 0.1cores &cong; 102</p></li><li class="list__item" id="ne00x5_28"><p id="ne00x5_36">Redis container will be <span class="control" id="ne00x5_37">OOM killed</span> if it tries to allocate more than 600MB of RAM, most likely making the pod fail.</p></li><li class="list__item" id="ne00x5_29"><p id="ne00x5_38">Redis will suffer <span class="control" id="ne00x5_39">CPU throttle</span> if it tries to use more than 100ms of CPU in every 100ms, (since we have 4 cores, available time would be 400ms every 100ms) causing performance degradation.</p></li><li class="list__item" id="ne00x5_30"><p id="ne00x5_40">Busybox container will be <span class="control" id="ne00x5_41">OOM killed</span> if it tries to allocate more than 200MB of RAM, resulting in a failed pod.</p></li><li class="list__item" id="ne00x5_31"><p id="ne00x5_42">Busybox will suffer <span class="control" id="ne00x5_43">CPU throttle</span> if it tries to use more than 30ms of CPU every 100ms, causing performance degradation.</p></li></ol></section><section class="chapter"><h2 id="kubernetes-requests" data-toc="kubernetes-requests">Kubernetes Requests</h2><p id="ne00x5_44">Kubernetes defines requests as a <span class="control" id="ne00x5_53">guaranteed minimum amount of a resource</span> to be used by a container.</p><p id="ne00x5_45">Basically, it will set the minimum amount of the resource for the container to consume.</p><p id="ne00x5_46">When a Pod is scheduled, kube-scheduler will check the Kubernetes requests in order to allocate it to a particular Node that can satisfy at least that amount for all containers in the Pod. If the requested amount is higher than the available resource, the Pod will not be scheduled and remain in Pending status.</p><p id="ne00x5_47">For more information about Pending status, check <a href="https://sysdig.com/blog/kubernetes-pod-pending-problems" id="ne00x5_54" data-external="true" rel="noopener noreferrer" target="_blank">Understanding Kubernetes Pod pending problems</a>.</p><p id="ne00x5_48">In this example, in the container definition we set a request for 100m cores of CPU and 4Mi of memory:</p><div class="code-block" data-lang="yaml">
    resources:
      requests:
        cpu: 0.1
        memory: 4Mi
</div><p id="ne00x5_50">Requests are used:</p><ul class="list _bullet" id="ne00x5_51"><li class="list__item" id="ne00x5_55"><p id="ne00x5_57">When allocating Pods to a Node, so the indicated requests by the containers in the Pod are satisfied.</p></li><li class="list__item" id="ne00x5_56"><p id="ne00x5_58">At runtime, the indicated amount of requests will be guaranteed as a minimum for the containers in that Pod.</p></li></ul><figure id="ne00x5_52"><img alt="K8s resources image4" src="images/k8s_resources_image4.png" title="K8s resources image4" width="800" height="303"></figure></section><section class="chapter"><h2 id="kubernetes-limits" data-toc="kubernetes-limits">Kubernetes Limits</h2><p id="ne00x5_59">Kubernetes defines <span class="control" id="ne00x5_65">limits</span> as a <span class="control" id="ne00x5_66">maximum amount of a resource</span> to be used by a container.</p><p id="ne00x5_60">This means that the container can never consume more than the memory amount or CPU amount indicated.</p><div class="code-block" data-lang="yaml">
    resources:
      limits:
        cpu: 0.5
        memory: 100Mi
</div><p id="ne00x5_62">Limits are used:</p><ul class="list _bullet" id="ne00x5_63"><li class="list__item" id="ne00x5_67"><p id="ne00x5_69">When allocating Pods to a Node. If no requests are set, by default, Kubernetes will assign requests = limits.</p></li><li class="list__item" id="ne00x5_68"><p id="ne00x5_70">At runtime, Kubernetes will check that the containers in the Pod are not consuming a higher amount of resources than indicated in the limit.</p></li></ul><figure id="ne00x5_64"><img alt="K8s resources image6" src="images/k8s_resources_image6.png" title="K8s resources image6" width="800" height="303"></figure></section><section class="chapter"><h2 id="cpu-particularities" data-toc="cpu-particularities">CPU particularities</h2><p id="ne00x5_71">CPU is a <span class="control" id="ne00x5_75">compressible resource</span>, meaning that it can be stretched in order to satisfy all the demand. In case that the processes request too much CPU, some of them will be throttled.</p><p id="ne00x5_72"><span class="control" id="ne00x5_76">CPU</span> represents <span class="control" id="ne00x5_77">computing processing time</span>, measured in cores.</p><ul class="list _bullet" id="ne00x5_73"><li class="list__item" id="ne00x5_78"><p id="ne00x5_81">You can use millicores (m) to represent smaller amounts than a core (e.g., 500m would be half a core)</p></li><li class="list__item" id="ne00x5_79"><p id="ne00x5_82">The minimum amount is 1m</p></li><li class="list__item" id="ne00x5_80"><p id="ne00x5_83">A Node might have more than one core available, so requesting CPU &gt; 1 is possible</p></li></ul><figure id="ne00x5_74"><img alt="Kubernetes limits and requests 1 1170x644" src="images/Kubernetes-Limits-and-Requests-1-1170x644.png" title="Kubernetes limits and requests 1 1170x644" width="800" height="440"></figure></section><section class="chapter"><h2 id="memory-particularities" data-toc="memory-particularities">Memory particularities</h2><p id="ne00x5_84">Memory is a non-compressible resource, meaning that it can&rsquo;t be stretched in the same manner as CPU. If a process doesn&rsquo;t get enough memory to work, the process is killed.</p><p id="ne00x5_85">Memory is measured in Kubernetes in <span class="control" id="ne00x5_88">bytes</span>.</p><ul class="list _bullet" id="ne00x5_86"><li class="list__item" id="ne00x5_89"><p id="ne00x5_92">You can use, E, P, T, G, M, k to represent Exabyte, Petabyte, Terabyte, Gigabyte, Megabyte and kilobyte, although only the last four are commonly used. (e.g., 500M, 4G)</p></li><li class="list__item" id="ne00x5_90"><p id="ne00x5_93">Warning: don&rsquo;t use lowercase m for memory (this represents Millibytes, which is ridiculously low)</p></li><li class="list__item" id="ne00x5_91"><p id="ne00x5_94">You can define Mebibytes using Mi, as well as the rest as Ei, Pi, Ti (e.g., 500Mi)</p><div class="code-block" data-lang="none">
A Mebibyte (and their analogues Kibibyte, Gibibyte,…) is 2 to the power of 20 bytes. 
It was created to avoid the confusion with the Kilo, Mega definitions of the metric system. 
You should be using this notation, as it’s the canonical definition for bytes, while Kilo and Mega are multiples of 1000
</div></li></ul><figure id="ne00x5_87"><img alt="Kubernetes limits and requests 2 1170x644" src="images/Kubernetes-Limits-and-Requests-2-1170x644.png" title="Kubernetes limits and requests 2 1170x644" width="800" height="440"></figure></section><section class="chapter"><h2 id="best-practices" data-toc="best-practices">Best practices</h2><p id="ne00x5_96">In very few cases should you be using limits to control your resources usage in Kubernetes. This is because if you want to avoid starvation (ensure that every important process gets its share), you should be using requests in the first place.</p><p id="ne00x5_97">By setting up limits, you are only preventing a process from retrieving additional resources in exceptional cases, causing an OOM kill in the event of memory, and Throttling in the event of CPU (process will need to wait until the CPU can be used again).</p><p id="ne00x5_98">For more information, check <a href="https://sysdig.com/blog/troubleshoot-kubernetes-oom/" id="ne00x5_101" data-external="true" rel="noopener noreferrer" target="_blank">the article about OOM and Throttling</a>.</p><p id="ne00x5_99">If you&rsquo;re setting a request value equal to the limit in all containers of a Pod, that Pod will get the Guaranteed Quality of Service.</p><p id="ne00x5_100">Note as well, that Pods that have a resource usage higher than the requests are more likely to be evicted, so setting up very low requests cause more harm than good.For more information, check the article about <a href="https://sysdig.com/blog/kubernetes-pod-evicted/" id="ne00x5_102" data-external="true" rel="noopener noreferrer" target="_blank">Pod eviction and Quality of Service</a>.</p></section><section class="chapter"><h2 id="namespace-resourcequota" data-toc="namespace-resourcequota">Namespace ResourceQuota</h2><p id="ne00x5_103">Thanks to namespaces, we can isolate Kubernetes resources into different groups, also called tenants.</p><p id="ne00x5_104">With <span class="control" id="ne00x5_115">ResourceQuotas</span>, you can <span class="control" id="ne00x5_116">set a memory or CPU limit to the entire namespace</span>, ensuring that entities in it can&rsquo;t consume more from that amount.</p><div class="code-block" data-lang="yaml">
apiVersion: v1
kind: ResourceQuota
metadata:
  name: mem-cpu-demo
spec:
  hard:
    requests.cpu: 2
    requests.memory: 1Gi
    limits.cpu: 3
    limits.memory: 2Gi
</div><ul class="list _bullet" id="ne00x5_106"><li class="list__item" id="ne00x5_117"><p id="ne00x5_121">requests.cpu: the maximum amount of CPU for the sum of all requests in this namespace</p></li><li class="list__item" id="ne00x5_118"><p id="ne00x5_122">requests.memory: the maximum amount of Memory for the sum of all requests in this namespace</p></li><li class="list__item" id="ne00x5_119"><p id="ne00x5_123">limits.cpu: the maximum amount of CPU for the sum of all limits in this namespace</p></li><li class="list__item" id="ne00x5_120"><p id="ne00x5_124">limits.memory: the maximum amount of memory for the sum of all limits in this namespace</p></li></ul><p id="ne00x5_107">Then, apply it to your namespace:</p><div class="code-block" data-lang="bash">
kubectl apply -f resourcequota.yaml --namespace=mynamespace
</div><p id="ne00x5_109">You can list the current ResourceQuota for a namespace with:</p><div class="code-block" data-lang="bash">
kubectl get resourcequota -n mynamespace
</div><p id="ne00x5_111">Note that if you set up ResourceQuota for a given resource in a namespace, you then need to specify limits or requests accordingly for every Pod in that namespace. If not, Kubernetes will return a &ldquo;failed quota&rdquo; error:</p><div class="code-block" data-lang="none">
Error from server (Forbidden): error when creating &quot;mypod.yaml&quot;: pods &quot;mypod&quot; is forbidden: failed quota: mem-cpu-demo: must specify limits.cpu,limits.memory,requests.cpu,requests.memory
</div><p id="ne00x5_113">In case you try to add a new Pod with container limits or requests that exceed the current ResourceQuota, Kubernetes will return an &ldquo;exceeded quota&rdquo; error:</p><div class="code-block" data-lang="none">
Error from server (Forbidden): error when creating &quot;mypod.yaml&quot;: pods &quot;mypod&quot; is forbidden: exceeded quota: mem-cpu-demo, requested: limits.memory=2Gi,requests.memory=2Gi, used: limits.memory=1Gi,requests.memory=1Gi, limited: limits.memory=2Gi,requests.memory=1Gi
</div></section><section class="chapter"><h2 id="namespace-limitrange" data-toc="namespace-limitrange">Namespace LimitRange</h2><p id="ne00x5_125">ResourceQuotas are useful if we want to restrict the total amount of a resource allocatable for a namespace. But what happens if we want to give default values to the elements inside?</p><p id="ne00x5_126"><span class="control" id="ne00x5_134">LimitRanges</span> are a Kubernetes policy that <span class="control" id="ne00x5_135">restricts the resource settings for each entity</span> in a namespace.</p><div class="code-block" data-lang="yaml">
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-resource-constraint
spec:
  limits:
    - default:
        cpu: 500m
      defaultRequest:
        cpu: 500m
      min:
        cpu: 100m
      max:
        cpu: &quot;1&quot;
      type: Container
</div><ul class="list _bullet" id="ne00x5_128"><li class="list__item" id="ne00x5_136"><p id="ne00x5_139"><code class="code" id="ne00x5_140">default</code>: Containers created will have this value if none is specified.</p></li><li class="list__item" id="ne00x5_137"><p id="ne00x5_141"><code class="code" id="ne00x5_142">min</code>: Containers created can&rsquo;t have limits or requests smaller than this.</p></li><li class="list__item" id="ne00x5_138"><p id="ne00x5_143"><code class="code" id="ne00x5_144">max</code>: Containers created can&rsquo;t have limits or requests bigger than this.</p></li></ul><p id="ne00x5_129">Later, if you create a new Pod with no requests or limits set, LimitRange will automatically set these values to all its containers:</p><div class="code-block" data-lang="yaml">
    Limits:
      cpu: 500m
    Requests:
      cpu: 100m
</div><p id="ne00x5_131">Now, imagine that you add a new Pod with 1200M as limit. You will receive the following error:</p><div class="code-block" data-lang="none">
Error from server (Forbidden): error when creating &quot;pods/mypod.yaml&quot;: pods &quot;mypod&quot; is forbidden: maximum cpu usage per Container is 1, but limit is 1200m
</div><p id="ne00x5_133">Note that by default, all containers in Pod will effectively have a request of 100m CPU, even with no LimitRanges set.</p></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="ne00x5_145">Choosing the optimal limits for our Kubernetes cluster is key in order to get the best of both energy consumption and costs.</p><p id="ne00x5_146">Oversizing or dedicating too many resources for our Pods may lead to costs skyrocketing.</p><p id="ne00x5_147">Undersizing or dedicating very few CPU or Memory will lead to applications not performing correctly, or even Pods being evicted.</p><p id="ne00x5_148">As mentioned, Kubernetes limits shouldn&rsquo;t be used, except in very specific situations, as they may cause more harm than good. There&rsquo;s a chance that a Container is killed in case of Out of Memory, or throttled in case of Out of CPU.</p><p id="ne00x5_149">For requests, use them when you need to ensure a process gets a guaranteed share of a resource.</p><figure id="ne00x5_150"><img alt="Kubernetes resources cheatsheet 1170x585" src="images/kubernetes-resources-cheatsheet-1170x585.png" title="Kubernetes resources cheatsheet 1170x585" width="800" height="400"></figure></section><div class="last-modified">11 September 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="k8s-update.html" class="navigation-links__prev">update application in k8s</a><a href="k8s-applications.html" class="navigation-links__next">applications</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>